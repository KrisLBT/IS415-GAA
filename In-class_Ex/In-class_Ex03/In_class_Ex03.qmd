---
title: "In-class exercise 3"
format:
  html:
    code-fold: True
    code-summary: "Show the code"
    toc: True
    toc-depth: 4
execute:
  eval: True
  echo: True
  message: False
  warning: False
date: "`r Sys.Date()`"
---

# Revising Hands-on Exercise 3

In this in-class exercise, we will be using the following packages:

-   maptools
-   sf
-   spatstat
-   tmap
-   tidyverse

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)
```

As there may be issues with installing maptools, you may use the following:

```{r}
#| eval: False
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

After that, you can rerun the first code block.

# Data import

Import the data using the following:

```{r}
mpsz_sf <- st_read(dsn='data/geospatial',
                   layer = 'MP14_SUBZONE_WEB_PL')
childcare_sf <- st_read("data/geospatial/ChildCareServices.geojson")
```

We notice that *childcare_sf* is in WGS 84. We can transform it using the following code block.

```{r}
childcare_sf <- st_transform(childcare_sf, 3414)
```

## Deriving CoastalOutline

First, we can plot the Master Plan Subzone Boundary 2014

```{r}
plot(mpsz_sf)
```

Then we can blend away the boundaries.

```{r}
sg_sf <- mpsz_sf %>%
  st_union()
```

```{r}
plot(sg_sf)
```

We use *st_union()* over *st_combine()* as *st_union()* will treat the output as a singular polygon while *st_combine()* will treat the individual subzones as their own polygon.

With that, we have made the CoastalOutline

# Geospatial Data Wrangling

## Creating ppp objects: sf method

We can use the more efficient *as.ppp()* method to convert to ppp.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
```

```{r}
summary(childcare_ppp)
```

# Creating owin object

```{r}
sg_owin <- as.owin(sg_sf)
```

```{r}
plot(sg_owin)
```

From here on out, the steps are the same.

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

Plotting

```{r fig.width=16, fig.heights=10}
par(mfrow=c(2,2))
plot(pg, main= "Punggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main= "Jurong West")
```

# Part 2

```{r}
pacman::p_load(sf, spNetwork, tmap, classInt, viridis, tidyverse)
```

# Import data

```{r}
network <- st_read(dsn="../../data/data/", 
                   layer="Punggol_St")
childcare <- st_read(dsn="../../data/data/",
                     layer="Punggol_CC")
```

To find out more about the data, use the str() function.

```{r}
str(network)
str(childcare)
```

# Plotting the data

```{r}
tmap_mode('view')
tm_shape(childcare)+
  tm_dots() +
  tm_shape(network) +
  tm_lines()
tmap_mode('plot')
```

## Network Constrained KDE (NetKDE) Analysis

### Preparing the lixels objects

```{r}
lixels <- lixelize_lines(network, 
                         750, 
                         mindist = 375)
                         #mindist should be half of the first value
```

## Generating line points

```{r}
samples <- lines_center(lixels)
```

### Performing NetKDE

Compute the NetKDE.

```{r}
densities <- nkde(network, 
                  events = childcare,
                  w = rep(1,nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
# care about bw (bandwith) and kernel_name 
```

What can we learn from the code chunk above?

-   kernel_name argument indicates that quartic kernel is used. Are possible kernel methods supported by spNetwork are: triangle, gaussian, scaled gaussian, tricube, cosine ,triweight, epanechnikov or uniform. method argument indicates that simple method is used to calculate the NKDE. Currently, spNetwork support three popular methods, they are:

    -   method=“simple”. This first method was presented by Xie et al. (2008) and proposes an intuitive solution. The distances between events and sampling points are replaced by network distances, and the formula of the kernel is adapted to calculate the density over a linear unit instead of an areal unit.
    -   method=“discontinuous”. The method is proposed by Okabe et al (2008), which equally “divides” the mass density of an event at intersections of lixels.
    -   method=“continuous”. If the discontinuous method is unbiased, it leads to a discontinuous kernel function which is a bit counter-intuitive. Okabe et al (2008) proposed another version of the kernel, that divide the mass of the density at intersection but adjusts the density before the intersection to make the function continuous.

The user guide of spNetwork package provide a comprehensive discussion of nkde(). You should read them at least once to have a basic understanding of the various parameters that can be used to calibrate the NetKDE model.

### Create density

```{r}
samples$density <- densities
lixels$density <- densities
```

Since the values are very small, rescale them:

```{r}
# rescaling to help the mapping
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
```

Generate the map

```{r}
tmap_mode('view')
tm_shape(lixels)+
  tm_lines(col="density")+
tm_shape(childcare)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

### Network Constrained G- and K-Function Analysis

In this section, we are going to perform complete spatial randomness (CSR) test by using kfunctions() of spNetwork package. The null hypothesis is defined as:

**Ho: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a street network in Punggol Planning Area.**

The CSR test is based on the assumption of the binomial point process which implies the hypothesis that the childcare centres are randomly and independently distributed over the street network.

If this hypothesis is rejected, we may infer that the distribution of childcare centres are spatially interacting and dependent on each other; as a result, they may form nonrandom patterns.

```{r}
kfun_childcare <- kfunctions(network, 
                             childcare,
                             start = 0, 
                             end = 1000, 
                             step = 50, 
                             width = 50, 
                             nsim = 50, 
                             resolution = 50,
                             verbose = FALSE, 
                             conf_int = 0.05)
```

What can we learn from the code chunk above?

There are ten arguments used in the code chunk above they are:

-   lines: A SpatialLinesDataFrame with the sampling points. The geometries must be a SpatialLinesDataFrame (may crash if some geometries are invalid).
-   points: A SpatialPointsDataFrame representing the points on the network. These points will be snapped on the network. start: A double, the start value for evaluating the k and g functions.
-   end: A double, the last value for evaluating the k and g functions.
-   step: A double, the jump between two evaluations of the k and g function.
-   width: The width of each donut for the g-function.
-   nsim: An integer indicating the number of Monte Carlo simulations required. In the above example, 50 simulation was performed. Note: most of the time, more simulations are required for inference
-   resolution: When simulating random points on the network, selecting a resolution will reduce greatly the calculation time. When resolution is null the random points can occur everywhere on the graph. If a value is specified, the edges are split according to this value and the random points are selected vertices on the new network.
-   conf_int: A double indicating the width confidence interval (default = 0.05).

For the usage of other arguments, you should refer to the user guide of spNetwork package.

The output of kfunctions() is a list with the following values:

-   plotkA, a ggplot2 object representing the values of the k-function
-   plotgA, a ggplot2 object representing the values of the g-function
-   valuesA, a DataFrame with the values used to build the plots

For example, we can visualise the ggplot2 object of k-function by using the code chunk below.

```{r}
kfun_childcare$plotk
```

The blue line is the empirical network K-function of the childcare centres in Punggol planning area. The gray envelop represents the results of the 50 simulations in the interval 2.5% - 97.5%. Because the blue line between the distance of 250m-400m are below the gray area, we can infer that the childcare centres in Punggol planning area resemble regular pattern at the distance of 250m-400m.
