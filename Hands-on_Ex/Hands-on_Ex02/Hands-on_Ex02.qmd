---
title: "Hands-on Exercise 02: Thematic Mapping and GeoVisualisation with R"
execute:
  warning: False
date: "`r Sys.Date()`"
---

# Overview

In this hands-on exercise, I will be creating chloropleth maps using an R package called **tmap**.

# Downloading the packages

In addition to tmap, the following packages will also be used:

-   **readr**\* for importing delimited text file

-   **tidyr**\* for tidying data

-   **dplyr**\* for wrangling data

-   **sf** for handling geospatial data

\* these packages are part of the tidyverse package

## Loading the packages in RStudio

```{r}
pacman::p_load(sf,tmap,tidyverse)
```

# Importing Data into R

## The Data Used

The following datasets will be used:

-   Master Plan 2014 Subzone Boundary (Web) from https://data.gov.sg

-   Singapore Residents by Planning Area / Subzon, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format from Department of Statistics, Singapore https://www.singstat.gov.sg/

## Importing Geospatial Data into R

Use the st_read() function of the sf package to import the subzone shapefile into R as a simple feature dataframe called mpsz

```{r}
mpsz <- st_read(dsn="data/geospatial", layer="MP14_SUBZONE_WEB_PL")
```

I can examine the content of mpsz wiith the following code chunk

```{r}
mpsz
```

## Importing Attribute Data into R

Next, I will import attribute data and save the file into an R dataframe called popdata

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")
```

## Data Preparation

Before a thematic map can be prepared, I will have to prepare a data table with 2020 values. It will include the following variables:

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,

-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,

-   AGED: age group 65 and above

-   TOTAL: all age group, and

-   DEPENDENCY: the ratio between young and aged against economy active group

### Data Wrangling

The following data wrangling and transformation functions will be used:

-   *pivot_wider()* of **tidyr** package, and
-   *mutate(), filter(), group_by()* and *select()* of **dplyr** package

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)

```

### Joining the Attribute Data

Before we can perform the georelational join, 1 extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ are made up of lower- and uppercase while SUBZONE_N and PLN_AREA_N are in uppercase

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next, the *left_join\_* of **dplyr** is used to join the geographical data and attribute table using planning subzone name e.g. *SUBZONE_N* and *SZ* as the common identifier

```{r}

mpsz_pop2020 <- left_join(mpsz, popdata2020, 
                          by = c("SUBZONE_N"= "SZ"))
```

Next, I will write an rds:

```{r}
write_rds(mpsz_pop2020, "data/rds/mpszpop2020.rds")

```

# Chloropleth Mapping Geospatial Data using **tmap**

Two approaches can be used to prepare a thematic map using **tmap**. They are:

-   Plotting a thematic map quickly using *qtm()*

-   Plotting a highly customisable thematic map using **tmap**'s elements

## Plotting a Chloropleth Map Quickly by Using *qtm()*

The code chunk will draw a cartographic standard chloropleth map as shown below:

```{r}
tmap_mode("plot")

qtm(mpsz_pop2020,
    fill="DEPENDENCY")

```

Learning points:

-   *tmap_mode()* with "plot" option is used to produce a static map. For interactive mode, the "view" option should be used.

-   *fill* argument is used to map the attribute (i.e. DEPENDENCY)

## Creating a Choropleth Map by Using **tmap**’s Elements

Whle *gtm()* is very fast and easy, the disadvatage is that the aesthetics of individual layers are difficult to control. To draw a high quality cartographic chloropleth map, **tmap**'s drawing elements should be used

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "Dependency ratio") +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))

```

The following sections will break down the code and explain what each individual element does.

#### Drawing the Base Layer

The basic building block of **tmap** is *tm_shape()* followed by one or more elements such as *tm_fill()* and *tm_polygons()*

In the code chunk below, *tm_shape()* is used to define the input data and *tm_polygons()* is used to draw the planning subzone polygons

```{r}
tm_shape(mpsz_pop2020) +
  tm_polygons()

```

#### Drawing a Map with *tm_polygons()*

To draw a chloropleth map showing a the geographical distribution of a selected variable by planning subzone, I assign the target variable such as *DEPENDENCY* to *tm_polygons()*

```{r}
tm_shape(mpsz_pop2020) + 
  tm_polygons("DEPENDENCY")
```

Things to learn from *tm_polygons()*:

-   The default interval binning used to draw the chloropleth map is called “pretty”. A detailed discussion of the data classification methods supported by **tmap** will be provided in sub-section 4.3.
-   The default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 4.4.
-   By default, Missing value will be shaded in grey.

#### Drawing a Map Using *tm_fill()* and *tm_border()*

*tm_polygons()* is a wrapper of *tm_fill()* and *tm_border()*. *tm_fill()* shades the polygons by using the default colour scheme and *tm_borders()* adds the borders of the shapefile onto the chloropleth map.

The following code chunk draws a chloropleth map using *tm_fill()* alone

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY")
```

To add the boundaries of the planning subzones, *tm_borders()* will be used:

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY") +
  tm_borders(lwd = 0.1,  alpha = 1)
```

Notice that light-gray border lines have been added on the choropleth map.

The *alpha* argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

Beside *alpha* argument, there are three other arguments for tm_borders(), they are:

-   *col* = border colour,
-   *lwd* = border line width. The default is 1, and
-   *lty* = border line type. The default is “solid”.

### Data Classificiation Methods of **tmap**

Most chloropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

**tmap** provides a total ten data classification methods, namely: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*.

To define a data classification method, the *style* argument of *tm_fill()* or *tm_polygons()* will be used.

#### Using Built-in Classification Methods

The code chunk below shows a quantile data classficiation that uses 5 classes:

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "jenks") +
  tm_borders(alpha = 0.5)
```

In the code chunk below, *equal* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5)
```

#### DIY

##### Different Classfication Methods

In the code chunk below, *kmeans* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "kmeans") +
  tm_borders(alpha = 0.5)
```

In the code chunk below, *hclust* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "hclust") +
  tm_borders(alpha = 0.5)
```

In the code chunk below, *bclust* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "bclust") +
  tm_borders(alpha = 0.5)
```

##### Different Number of Classes

With n = 5

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "hclust") +
  tm_borders(alpha = 0.5)
```

With n = 10

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 10,
          style = "hclust") +
  tm_borders(alpha = 0.5)
```

With n = 15

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 15,
          style = "hclust") +
  tm_borders(alpha = 0.5)
```

With n = 20

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 20,
          style = "hclust") +
  tm_borders(alpha = 0.5)
```

### Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the *tm_fill()*. It is important to note that, in **tmap** the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).

it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of **DEPENDENCY** field.

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, I will plot the chLoropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +
  tm_borders(alpha = 0.5)
```

### Colour Scheme

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package

#### Using ColorBrewer palette

To change the colour, I assign the preferred colour to the palette argument of *tm_fill()*

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "Blues") +
  tm_borders(alpha = 0.5)
```

To reverse the colour scheme, add an "-" behind the palette value as shown below:

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "-Blues") +
  tm_borders(alpha = 0.5)
```

### Map Layout

Map layout refers to the combination of all map elements into a cohesive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.

#### Map Legend

In **tmap**, several legend options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "jenks", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```

#### Map Style

**tmap** allows a wide variety of layout settings to be changed. They can be called by using *tmap_style()*.

The code chunk below shows the classic style is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "-Greens") +
  tm_borders(alpha = 0.5) +
  tmap_style("classic")
```

#### Cartographic funiture

Beside map style, **tmap** also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, *tm_compass(),* *tm_scale_bar()* and *tm_grid()* are used to add compass, scale bar and grid lines respectively onto the chloropleth map.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "No. of persons") +
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))

```

To reset to the default style, refer to the code chunk below:

```{r}
tmap_style("white")
```

#### Drawinig Facet Chloropleth Maps

**Facet maps** are composed of many maps arranged side-by-side and occassionally, vertically. They enable the visualisation of how spatial relationships shift with respect to another variable.

In **tmap**, this can be done in 3 ways:

-   by assigning multiple values to at least one of the aesthetic arguments,

-   by defining a group-by variable in *tm_facets()* and,

-   by creating multiple stand-alone maps with *tmap_arrange()*

##### By Assigning Multiple Values to At Least One of the Aesthetic Arguments

In the code chunk below, small chloropleth maps are created by defining **ncols** in *tm_fill()*:

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill(c("YOUNG", "AGED"),
          style = "equal", 
          palette = "Blues") +
  tm_layout(legend.position = c("right", "bottom")) +
  tm_borders(alpha = 0.5) +
  tmap_style("white")
```

In this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments

```{r}
tm_shape(mpsz_pop2020)+ 
  tm_polygons(c("DEPENDENCY","AGED"),
          style = c("equal", "quantile"), 
          palette = list("Blues","Greens")) +
  tm_layout(legend.position = c("right", "bottom"))
```

##### By Defining a Group-by Variable in *tm_facets()*

```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          thres.poly = 0) + 
  tm_facets(by="REGION_N", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = FALSE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(alpha = 0.5)
```

##### By Creating Multiple Stand-alone Maps with *tmaps_arrange()*

In this example, multiple small choropleth maps are created by creating multiple stand-alone maps with **tmap_arrange()**.

```{r}
youngmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("YOUNG", 
              style = "quantile", 
              palette = "Blues")

agedmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("AGED", 
              style = "quantile", 
              palette = "Blues")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

### Mappping Spatial Object Meeting a Selection Criterion

Instead of creating facets maps, you can also use selection funtion to map spatial objects meeting the selection criterion.

```{r}
tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION", ])+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```
